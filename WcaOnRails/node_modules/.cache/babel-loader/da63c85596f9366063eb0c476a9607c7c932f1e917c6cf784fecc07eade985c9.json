{"ast":null,"code":"import _set from \"lodash/set\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { useCallback } from 'react';\n// This aims to provide a quick wrapper to:\n//   - create an updater for a given path in a state created by useState or similar.\n//   - take into account how react-semantic-ui provides the input value through its\n//   onChange method, which must have this signature:\n//   onChange(event: ChangeEvent, data: object)\n// Example usage:\n// const setMyProp = useNestedInputUpdater(setGlobalState, 'myProp');\n//\n// It can be used directly like any other set method:\n// setMyProp('my val');\n// Or passed as the 'onChange' callback of a react-semantic-ui input.\n\nvar useNestedInputUpdater = function useNestedInputUpdater(updater, path) {\n  return useCallback(function (ev) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    var value = data ? data.value : ev;\n    // updater is assumed to come from useState or similar, so we can pass it a\n    // function that act based on the previous state.\n    updater(function (prevState) {\n      // This is a react state, we can't just modify something in prevValue,\n      // we need to create a brand new copy.\n      var newState = _objectSpread({}, prevState);\n      _set(newState, path, value);\n      return newState;\n    });\n  }, [updater, path]);\n};\nexport default useNestedInputUpdater;","map":{"version":3,"names":["useCallback","useNestedInputUpdater","updater","path","ev","data","arguments","length","undefined","value","prevState","newState","_objectSpread","_set"],"sources":["/app/WcaOnRails/app/webpacker/lib/hooks/useNestedInputUpdater.js"],"sourcesContent":["import { useCallback } from 'react';\nimport _ from 'lodash';\n\n// This aims to provide a quick wrapper to:\n//   - create an updater for a given path in a state created by useState or similar.\n//   - take into account how react-semantic-ui provides the input value through its\n//   onChange method, which must have this signature:\n//   onChange(event: ChangeEvent, data: object)\n// Example usage:\n// const setMyProp = useNestedInputUpdater(setGlobalState, 'myProp');\n//\n// It can be used directly like any other set method:\n// setMyProp('my val');\n// Or passed as the 'onChange' callback of a react-semantic-ui input.\n\nconst useNestedInputUpdater = (updater, path) => useCallback((ev, data = undefined) => {\n  const value = data ? data.value : ev;\n  // updater is assumed to come from useState or similar, so we can pass it a\n  // function that act based on the previous state.\n  updater((prevState) => {\n    // This is a react state, we can't just modify something in prevValue,\n    // we need to create a brand new copy.\n    const newState = { ...prevState };\n    _.set(newState, path, value);\n    return newState;\n  });\n}, [updater, path]);\n\nexport default useNestedInputUpdater;\n"],"mappings":";;;;;;AAAA,SAASA,WAAW,QAAQ,OAAO;AAGnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAAIC,OAAO,EAAEC,IAAI;EAAA,OAAKH,WAAW,CAAC,UAACI,EAAE,EAAuB;IAAA,IAArBC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGE,SAAS;IAChF,IAAMC,KAAK,GAAGJ,IAAI,GAAGA,IAAI,CAACI,KAAK,GAAGL,EAAE;IACpC;IACA;IACAF,OAAO,CAAC,UAACQ,SAAS,EAAK;MACrB;MACA;MACA,IAAMC,QAAQ,GAAAC,aAAA,KAAQF,SAAS,CAAE;MACjCG,IAAA,CAAMF,QAAQ,EAAER,IAAI,EAAEM,KAAK,CAAC;MAC5B,OAAOE,QAAQ;IACjB,CAAC,CAAC;EACJ,CAAC,EAAE,CAACT,OAAO,EAAEC,IAAI,CAAC,CAAC;AAAA;AAEnB,eAAeF,qBAAqB"},"metadata":{},"sourceType":"module","externalDependencies":[]}