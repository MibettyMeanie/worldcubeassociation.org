{"ast":null,"code":"function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { events, formats } from \"../../lib/wca-data.js.erb\";\nimport { buildActivityCode, parseActivityCode } from \"../../lib/utils/wcif\";\nimport { matchResult, pluralize } from \"../../lib/utils/edit-events\";\nvar DEFAULT_TIME_LIMIT = {\n  centiseconds: 10 * 60 * 100,\n  cumulativeRoundIds: []\n};\nexport var generateWcifRound = function generateWcifRound(eventId, roundNumber) {\n  var event = events.byId[eventId];\n  return {\n    id: buildActivityCode({\n      eventId: eventId,\n      roundNumber: roundNumber\n    }),\n    format: event.recommendedFormat().id,\n    timeLimit: event.canChangeTimeLimit ? DEFAULT_TIME_LIMIT : null,\n    cutoff: null,\n    advancementCondition: null,\n    results: [],\n    groups: [],\n    scrambleSetCount: 1\n  };\n};\n\n/**\n * Removes the roundIds from the cumulativeRoundIds of the specified event.\n *\n * @param {collection} wcifEvents Will be modified in place.\n * @param {Array}      roundIdsToRemove Rounds to be removed from all cumulativeRoundIds.\n */\nexport var removeSharedTimeLimits = function removeSharedTimeLimits(event, roundIdsToRemove) {\n  if (event.rounds) {\n    return _objectSpread(_objectSpread({}, event), {}, {\n      rounds: event.rounds.map(function (round) {\n        return removeSharedTimeLimitsFromRound(round, roundIdsToRemove);\n      })\n    });\n  }\n  ;\n  return event;\n};\nvar removeSharedTimeLimitsFromRound = function removeSharedTimeLimitsFromRound(round, roundIdsToRemove) {\n  if (round.timeLimit) {\n    return _objectSpread(_objectSpread({}, round), {}, {\n      timeLimit: _objectSpread(_objectSpread({}, round.timeLimit), {}, {\n        cumulativeRoundIds: round.timeLimit.cumulativeRoundIds.filter(function (wcifRoundId) {\n          return !roundIdsToRemove.includes(wcifRoundId);\n        })\n      })\n    });\n  }\n  ;\n  return round;\n};\nexport var roundCutoffToString = function roundCutoffToString(wcifRound) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _short = _ref[\"short\"];\n  var cutoff = wcifRound.cutoff;\n  if (!cutoff) {\n    return '-';\n  }\n  var _parseActivityCode = parseActivityCode(wcifRound.id),\n    eventId = _parseActivityCode.eventId;\n  var matchStr = matchResult(cutoff.attemptResult, eventId, {\n    \"short\": _short\n  });\n  if (_short) {\n    return \"Best of \".concat(cutoff.numberOfAttempts, \" \").concat(matchStr);\n  }\n  var explanationText = \"Competitors get \".concat(pluralize(cutoff.numberOfAttempts, 'attempt'), \" to get \").concat(matchStr, \".\");\n  explanationText += \" If they succeed, they get to do all \".concat(formats.byId[wcifRound.format].expectedSolveCount, \" solves.\");\n  return explanationText;\n};","map":{"version":3,"names":["events","formats","buildActivityCode","parseActivityCode","matchResult","pluralize","DEFAULT_TIME_LIMIT","centiseconds","cumulativeRoundIds","generateWcifRound","eventId","roundNumber","event","byId","id","format","recommendedFormat","timeLimit","canChangeTimeLimit","cutoff","advancementCondition","results","groups","scrambleSetCount","removeSharedTimeLimits","roundIdsToRemove","rounds","_objectSpread","map","round","removeSharedTimeLimitsFromRound","filter","wcifRoundId","includes","roundCutoffToString","wcifRound","_ref","arguments","length","undefined","short","_parseActivityCode","matchStr","attemptResult","concat","numberOfAttempts","explanationText","expectedSolveCount"],"sources":["/app/WcaOnRails/app/webpacker/components/EditEvents/utils.js"],"sourcesContent":["import { events, formats } from '../../lib/wca-data.js.erb';\nimport { buildActivityCode, parseActivityCode } from '../../lib/utils/wcif';\nimport { matchResult, pluralize } from '../../lib/utils/edit-events';\n\nconst DEFAULT_TIME_LIMIT = {\n  centiseconds: 10 * 60 * 100,\n  cumulativeRoundIds: [],\n};\n\nexport const generateWcifRound = (eventId, roundNumber) => {\n  const event = events.byId[eventId];\n\n  return {\n    id: buildActivityCode({\n      eventId,\n      roundNumber,\n    }),\n    format: event.recommendedFormat().id,\n    timeLimit: event.canChangeTimeLimit ? DEFAULT_TIME_LIMIT : null,\n    cutoff: null,\n    advancementCondition: null,\n    results: [],\n    groups: [],\n    scrambleSetCount: 1,\n  };\n};\n\n/**\n * Removes the roundIds from the cumulativeRoundIds of the specified event.\n *\n * @param {collection} wcifEvents Will be modified in place.\n * @param {Array}      roundIdsToRemove Rounds to be removed from all cumulativeRoundIds.\n */\nexport const removeSharedTimeLimits = (event, roundIdsToRemove) => {\n  if (event.rounds) {\n    return {\n      ...event,\n      rounds: event.rounds.map((round) => removeSharedTimeLimitsFromRound(round, roundIdsToRemove)),\n    };\n  };\n  return event;\n};\n\nconst removeSharedTimeLimitsFromRound = (round, roundIdsToRemove) => {\n  if (round.timeLimit) {\n    return {\n      ...round,\n      timeLimit: {\n        ...round.timeLimit,\n        cumulativeRoundIds: round.timeLimit.cumulativeRoundIds.filter((wcifRoundId) => (\n          !roundIdsToRemove.includes(wcifRoundId)\n        )),\n      },\n    };\n  };\n  return round;\n};\n\nexport const roundCutoffToString = (wcifRound, { short } = {}) => {\n  const { cutoff } = wcifRound;\n  if (!cutoff) {\n    return '-';\n  }\n\n  const { eventId } = parseActivityCode(wcifRound.id);\n  const matchStr = matchResult(cutoff.attemptResult, eventId, { short });\n  if (short) {\n    return `Best of ${cutoff.numberOfAttempts} ${matchStr}`;\n  }\n  let explanationText = `Competitors get ${pluralize(cutoff.numberOfAttempts, 'attempt')} to get ${matchStr}.`;\n  explanationText += ` If they succeed, they get to do all ${formats.byId[wcifRound.format].expectedSolveCount} solves.`;\n  return explanationText;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}