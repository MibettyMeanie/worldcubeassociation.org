{"ast":null,"code":"var _reducers;\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { generateWcifRound, removeSharedTimeLimits } from \"../utils\";\nimport { AddEvent, AddRounds, ChangesSaved, RemoveEvent, RemoveRounds, SetScrambleSetCount, UpdateRoundFormat, UpdateAdvancementCondition, UpdateCutoff, UpdateQualification, UpdateTimeLimit } from \"./actions\";\n\n/**\n * Updates 1 or more rounds\n * @param {Event[]} wcifEvents\n * @param {ActivityCode[]} roundIds\n * @param {function(Round): Partial<Round>} mapper\n * @returns {Event[]}\n */\nvar updateForRounds = function updateForRounds(wcifEvents, roundIds, mapper) {\n  return wcifEvents.map(function (event) {\n    var _event$rounds;\n    return _objectSpread(_objectSpread({}, event), {}, {\n      rounds: event !== null && event !== void 0 && (_event$rounds = event.rounds) !== null && _event$rounds !== void 0 && _event$rounds.length ? event.rounds.map(function (round) {\n        return roundIds.includes(round.id) ? _objectSpread(_objectSpread({}, round), mapper(round)) : round;\n      }) : event.rounds\n    });\n  });\n};\nvar reducers = (_reducers = {}, _defineProperty(_reducers, ChangesSaved, function (state) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    initialWcifEvents: state.wcifEvents\n  });\n}), _defineProperty(_reducers, AddEvent, function (state, _ref) {\n  var payload = _ref.payload;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    wcifEvents: state.wcifEvents.map(function (event) {\n      return event.id === payload.eventId ? _objectSpread(_objectSpread({}, event), {}, {\n        rounds: []\n      }) : event;\n    })\n  });\n}), _defineProperty(_reducers, RemoveEvent, function (state, _ref2) {\n  var payload = _ref2.payload;\n  var eventId = payload.eventId;\n  var event = state.wcifEvents.find(function (e) {\n    return e.id === eventId;\n  });\n  var roundIdsToRemove = event.rounds.map(function (round) {\n    return round.id;\n  });\n  return _objectSpread(_objectSpread({}, state), {}, {\n    wcifEvents: state.wcifEvents.map(function (e) {\n      return e.id === payload.eventId ? {\n        id: e.id,\n        rounds: null\n      } : removeSharedTimeLimits(e, roundIdsToRemove);\n    })\n  });\n}), _defineProperty(_reducers, AddRounds, function (state, _ref3) {\n  var _event$rounds2;\n  var payload = _ref3.payload;\n  var eventId = payload.eventId,\n    roundsToAddCount = payload.roundsToAddCount;\n  var event = state.wcifEvents.find(function (e) {\n    return e.id === eventId;\n  });\n  var existingRounds = (_event$rounds2 = event.rounds) !== null && _event$rounds2 !== void 0 ? _event$rounds2 : [];\n  var newRounds = Array(roundsToAddCount).fill(null).map(function (_, i) {\n    return generateWcifRound(eventId, existingRounds.length + i + 1);\n  });\n  return _objectSpread(_objectSpread({}, state), {}, {\n    wcifEvents: state.wcifEvents.map(function (e) {\n      return e.id === eventId ? _objectSpread(_objectSpread({}, e), {}, {\n        rounds: [].concat(_toConsumableArray(existingRounds), _toConsumableArray(newRounds))\n      }) : e;\n    })\n  });\n}), _defineProperty(_reducers, RemoveRounds, function (state, _ref4) {\n  var payload = _ref4.payload;\n  var eventId = payload.eventId,\n    roundsToRemoveCount = payload.roundsToRemoveCount;\n  var event = state.wcifEvents.find(function (e) {\n    return e.id === eventId;\n  });\n\n  // For removing shared cumulative time limits from other rounds\n  var roundIdsToRemove = event.rounds.slice(event.rounds.length - roundsToRemoveCount).map(function (round) {\n    return round.id;\n  });\n\n  // Creating a copy because otherwise, we would be mutating a reference that points to\n  // our reducer's state (and if you just only openend the page, also to the initialWcif state!)\n  var newEvent = _objectSpread(_objectSpread({}, event), {}, {\n    rounds: event.rounds.slice(0, event.rounds.length - roundsToRemoveCount)\n  });\n  if (newEvent.rounds.length > 0) {\n    // Final rounds must not have an advance to next round requirement.\n    newEvent.rounds[newEvent.rounds.length - 1].advancementCondition = null;\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    wcifEvents: state.wcifEvents.map(function (e) {\n      return e.id === eventId ? newEvent : removeSharedTimeLimits(e, roundIdsToRemove);\n    })\n  });\n}), _defineProperty(_reducers, UpdateRoundFormat, function (state, _ref5) {\n  var payload = _ref5.payload;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    wcifEvents: updateForRounds(state.wcifEvents, [payload.roundId], function () {\n      return {\n        format: payload.format\n      };\n    })\n  });\n}), _defineProperty(_reducers, SetScrambleSetCount, function (state, _ref6) {\n  var payload = _ref6.payload;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    wcifEvents: updateForRounds(state.wcifEvents, [payload.roundId], function () {\n      return {\n        scrambleSetCount: payload.scrambleSetCount\n      };\n    })\n  });\n}), _defineProperty(_reducers, UpdateCutoff, function (state, _ref7) {\n  var payload = _ref7.payload;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    wcifEvents: updateForRounds(state.wcifEvents, [payload.roundId], function () {\n      return {\n        cutoff: payload.cutoff\n      };\n    })\n  });\n}), _defineProperty(_reducers, UpdateTimeLimit, function (state, _ref8) {\n  var payload = _ref8.payload;\n  // payload may have a new group of round ids to share a cumulative time limit;\n  // if not, it itself may have formerly been in a cumulative time limit\n  // so first, remove all those rounds (or the round itself) from _all_ cumulative time limits\n  var eventsWithRoundsRemovedFromCumulativeTimeLimits = updateForRounds(state.wcifEvents, state.wcifEvents.flatMap(function (event) {\n    var _event$rounds$map, _event$rounds3;\n    return (_event$rounds$map = (_event$rounds3 = event.rounds) === null || _event$rounds3 === void 0 ? void 0 : _event$rounds3.map(function (round) {\n      return round.id;\n    })) !== null && _event$rounds$map !== void 0 ? _event$rounds$map : [];\n  }), function (round) {\n    var _round$timeLimit;\n    return (_round$timeLimit = round.timeLimit) !== null && _round$timeLimit !== void 0 && _round$timeLimit.cumulativeRoundIds ? {\n      timeLimit: _objectSpread(_objectSpread({}, round.timeLimit), {}, {\n        cumulativeRoundIds: round.timeLimit.cumulativeRoundIds.filter(function (roundId) {\n          return ![payload.roundId].concat(_toConsumableArray(payload.timeLimit.cumulativeRoundIds)).includes(roundId);\n        })\n      })\n    } : {};\n  });\n\n  // then, add the (potential) new shared cumulative time limit to _all involved rounds_\n  return _objectSpread(_objectSpread({}, state), {}, {\n    wcifEvents: updateForRounds(eventsWithRoundsRemovedFromCumulativeTimeLimits, [payload.roundId].concat(_toConsumableArray(payload.timeLimit.cumulativeRoundIds)), function () {\n      return {\n        timeLimit: payload.timeLimit\n      };\n    })\n  });\n}), _defineProperty(_reducers, UpdateAdvancementCondition, function (state, _ref9) {\n  var payload = _ref9.payload;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    wcifEvents: updateForRounds(state.wcifEvents, [payload.roundId], function () {\n      return {\n        advancementCondition: payload.advancementCondition\n      };\n    })\n  });\n}), _defineProperty(_reducers, UpdateQualification, function (state, _ref10) {\n  var payload = _ref10.payload;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    wcifEvents: state.wcifEvents.map(function (event) {\n      return event.id === payload.eventId ? _objectSpread(_objectSpread({}, event), {}, {\n        qualification: payload.qualification\n      }) : event;\n    })\n  });\n}), _reducers);\nexport default function rootReducer(state, action) {\n  var reducer = reducers[action.type];\n  if (reducer) {\n    return reducer(state, action);\n  }\n  return state;\n}","map":{"version":3,"names":["generateWcifRound","removeSharedTimeLimits","AddEvent","AddRounds","ChangesSaved","RemoveEvent","RemoveRounds","SetScrambleSetCount","UpdateRoundFormat","UpdateAdvancementCondition","UpdateCutoff","UpdateQualification","UpdateTimeLimit","updateForRounds","wcifEvents","roundIds","mapper","map","event","_event$rounds","_objectSpread","rounds","length","round","includes","id","reducers","_reducers","_defineProperty","state","initialWcifEvents","_ref","payload","eventId","_ref2","find","e","roundIdsToRemove","_ref3","_event$rounds2","roundsToAddCount","existingRounds","newRounds","Array","fill","_","i","concat","_toConsumableArray","_ref4","roundsToRemoveCount","slice","newEvent","advancementCondition","_ref5","roundId","format","_ref6","scrambleSetCount","_ref7","cutoff","_ref8","eventsWithRoundsRemovedFromCumulativeTimeLimits","flatMap","_event$rounds$map","_event$rounds3","_round$timeLimit","timeLimit","cumulativeRoundIds","filter","_ref9","_ref10","qualification","rootReducer","action","reducer","type"],"sources":["/app/WcaOnRails/app/webpacker/components/EditEvents/store/reducer.js"],"sourcesContent":["import { generateWcifRound, removeSharedTimeLimits } from '../utils';\nimport {\n  AddEvent,\n  AddRounds,\n  ChangesSaved,\n  RemoveEvent,\n  RemoveRounds,\n  SetScrambleSetCount,\n  UpdateRoundFormat,\n  UpdateAdvancementCondition,\n  UpdateCutoff,\n  UpdateQualification,\n  UpdateTimeLimit,\n} from './actions';\n\n/**\n * Updates 1 or more rounds\n * @param {Event[]} wcifEvents\n * @param {ActivityCode[]} roundIds\n * @param {function(Round): Partial<Round>} mapper\n * @returns {Event[]}\n */\nconst updateForRounds = (wcifEvents, roundIds, mapper) => wcifEvents.map((event) => ({\n  ...event,\n  rounds: event?.rounds?.length\n    ? event.rounds.map((round) => (roundIds.includes(round.id) ? {\n      ...round,\n      ...mapper(round),\n    } : round)) : event.rounds,\n}));\n\nconst reducers = {\n  [ChangesSaved]: (state) => ({\n    ...state,\n    initialWcifEvents: state.wcifEvents,\n  }),\n\n  [AddEvent]: (state, { payload }) => ({\n    ...state,\n    wcifEvents: state.wcifEvents.map((event) => (event.id === payload.eventId ? ({\n      ...event,\n      rounds: [],\n    }) : event)),\n  }),\n\n  [RemoveEvent]: (state, { payload }) => {\n    const { eventId } = payload;\n    const event = state.wcifEvents.find((e) => e.id === eventId);\n    const roundIdsToRemove = event.rounds.map((round) => round.id);\n\n    return {\n      ...state,\n      wcifEvents: state.wcifEvents.map((e) => (e.id === payload.eventId ? ({\n        id: e.id,\n        rounds: null,\n      }) : removeSharedTimeLimits(e, roundIdsToRemove))),\n    };\n  },\n\n  [AddRounds]: (state, { payload }) => {\n    const { eventId, roundsToAddCount } = payload;\n\n    const event = state.wcifEvents.find((e) => e.id === eventId);\n    const existingRounds = event.rounds ?? [];\n\n    const newRounds = Array(roundsToAddCount).fill(null).map((_, i) => (\n      generateWcifRound(eventId, existingRounds.length + i + 1)\n    ));\n\n    return {\n      ...state,\n      wcifEvents: state.wcifEvents.map((e) => (e.id === eventId ? ({\n        ...e, rounds: [...existingRounds, ...newRounds],\n      }) : e)),\n    };\n  },\n\n  [RemoveRounds]: (state, { payload }) => {\n    const { eventId, roundsToRemoveCount } = payload;\n\n    const event = state.wcifEvents.find((e) => e.id === eventId);\n\n    // For removing shared cumulative time limits from other rounds\n    const roundIdsToRemove = event.rounds.slice(event.rounds.length - roundsToRemoveCount)\n      .map((round) => round.id);\n\n    // Creating a copy because otherwise, we would be mutating a reference that points to\n    // our reducer's state (and if you just only openend the page, also to the initialWcif state!)\n    const newEvent = {\n      ...event,\n      rounds: event.rounds.slice(0, event.rounds.length - roundsToRemoveCount),\n    };\n\n    if (newEvent.rounds.length > 0) {\n      // Final rounds must not have an advance to next round requirement.\n      newEvent.rounds[newEvent.rounds.length - 1].advancementCondition = null;\n    }\n\n    return {\n      ...state,\n      wcifEvents: state.wcifEvents.map((e) => (\n        e.id === eventId ? newEvent : removeSharedTimeLimits(e, roundIdsToRemove)\n      )),\n    };\n  },\n\n  [UpdateRoundFormat]: (state, { payload }) => ({\n    ...state,\n    wcifEvents: updateForRounds(state.wcifEvents, [payload.roundId], () => ({\n      format: payload.format,\n    })),\n  }),\n\n  [SetScrambleSetCount]: (state, { payload }) => ({\n    ...state,\n    wcifEvents: updateForRounds(state.wcifEvents, [payload.roundId], () => ({\n      scrambleSetCount: payload.scrambleSetCount,\n    })),\n  }),\n\n  [UpdateCutoff]: (state, { payload }) => ({\n    ...state,\n    wcifEvents: updateForRounds(state.wcifEvents, [payload.roundId], () => ({\n      cutoff: payload.cutoff,\n    })),\n  }),\n\n  [UpdateTimeLimit]: (state, { payload }) => {\n    // payload may have a new group of round ids to share a cumulative time limit;\n    // if not, it itself may have formerly been in a cumulative time limit\n    // so first, remove all those rounds (or the round itself) from _all_ cumulative time limits\n    const eventsWithRoundsRemovedFromCumulativeTimeLimits = updateForRounds(\n      state.wcifEvents,\n      state.wcifEvents.flatMap((event) => event.rounds?.map((round) => round.id) ?? []),\n      (round) => (round.timeLimit?.cumulativeRoundIds ? {\n        timeLimit: {\n          ...round.timeLimit,\n          cumulativeRoundIds: round.timeLimit.cumulativeRoundIds.filter((roundId) => ![\n            payload.roundId,\n            ...payload.timeLimit.cumulativeRoundIds,\n          ].includes(roundId)),\n        },\n      } : {}),\n    );\n\n    // then, add the (potential) new shared cumulative time limit to _all involved rounds_\n    return {\n      ...state,\n      wcifEvents: updateForRounds(\n        eventsWithRoundsRemovedFromCumulativeTimeLimits,\n        [payload.roundId, ...payload.timeLimit.cumulativeRoundIds],\n        () => ({ timeLimit: payload.timeLimit }),\n      ),\n    };\n  },\n\n  [UpdateAdvancementCondition]: (state, { payload }) => ({\n    ...state,\n    wcifEvents: updateForRounds(state.wcifEvents, [payload.roundId], () => ({\n      advancementCondition: payload.advancementCondition,\n    })),\n  }),\n\n  [UpdateQualification]: (state, { payload }) => ({\n    ...state,\n    wcifEvents: state.wcifEvents.map((event) => (event.id === payload.eventId ? ({\n      ...event,\n      qualification: payload.qualification,\n    }) : event)),\n  }),\n};\n\nexport default function rootReducer(state, action) {\n  const reducer = reducers[action.type];\n  if (reducer) {\n    return reducer(state, action);\n  }\n  return state;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}