{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _wrapRegExp() { _wrapRegExp = function _wrapRegExp(e, r) { return new BabelRegExp(e, void 0, r); }; var e = RegExp.prototype, r = new WeakMap(); function BabelRegExp(e, t, p) { var o = new RegExp(e, t); return r.set(o, p || r.get(e)), _setPrototypeOf(o, BabelRegExp.prototype); } function buildGroups(e, t) { var p = r.get(t); return Object.keys(p).reduce(function (r, t) { var o = p[t]; if (\"number\" == typeof o) r[t] = e[o];else { for (var i = 0; void 0 === e[o[i]] && i + 1 < o.length;) i++; r[t] = e[o[i]]; } return r; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (r) { var t = e.exec.call(this, r); if (t) { t.groups = buildGroups(t, this); var p = t.indices; p && (p.groups = buildGroups(p, this)); } return t; }, BabelRegExp.prototype[Symbol.replace] = function (t, p) { if (\"string\" == typeof p) { var o = r.get(this); return e[Symbol.replace].call(this, t, p.replace(/\\$<([^>]+)>/g, function (e, r) { var t = o[r]; return \"$\" + (Array.isArray(t) ? t.join(\"$\") : t); })); } if (\"function\" == typeof p) { var i = this; return e[Symbol.replace].call(this, t, function () { var e = arguments; return \"object\" != typeof e[e.length - 1] && (e = [].slice.call(e)).push(buildGroups(e, i)), p.apply(this, e); }); } return e[Symbol.replace].call(this, t, p); }, _wrapRegExp.apply(this, arguments); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nvar HEX_BASE = 16;\nvar HEX_CHANNEL_REGEX = /*#__PURE__*/_wrapRegExp(/^#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/, {\n  r: 1,\n  g: 2,\n  b: 3\n});\n\n/**\n * Convert a HEX color code to RGB values.\n *\n * @example\n * // returns [255, 255, 255]\n * getTextColor('#ffffff');\n *\n * @param {string} hexColor HEX color code to convert to RGB\n *\n * @returns {Array<number>} RBG values, defaults to `[0, 0, 0]` if `hexColor` cannot be parsed\n */\nexport var hexToRgb = function hexToRgb(hexColor) {\n  var match = hexColor.match(HEX_CHANNEL_REGEX);\n  if (match !== null) {\n    return [parseInt(match.groups.r, HEX_BASE), parseInt(match.groups.g, HEX_BASE), parseInt(match.groups.b, HEX_BASE)];\n  }\n  return [0, 0, 0];\n};\nvar WHITE = '#ffffff';\nvar BLACK = '#000000';\n\n/**\n * Compute appropriate text color (black or white) based on how \"light\" or \"dark\"\n * the background color of a calendar item is.\n *\n * @example\n * // returns #000000 (black given white background color)\n * getTextColor('#ffffff');\n *\n * @param {string} backgroundColor Calendar item's background color (in HEX)\n *\n * @returns {string} white for \"dark\" backgrounds, black for \"light\" backgrounds\n */\nexport var getTextColor = function getTextColor(backgroundColor) {\n  var _hexToRgb = hexToRgb(backgroundColor),\n    _hexToRgb2 = _slicedToArray(_hexToRgb, 3),\n    red = _hexToRgb2[0],\n    green = _hexToRgb2[1],\n    blue = _hexToRgb2[2];\n  // formula from https://stackoverflow.com/a/3943023\n  return red * 0.299 + green * 0.587 + blue * 0.114 > 186 ? BLACK : WHITE;\n};","map":{"version":3,"names":["HEX_BASE","HEX_CHANNEL_REGEX","_wrapRegExp","r","g","b","hexToRgb","hexColor","match","parseInt","groups","WHITE","BLACK","getTextColor","backgroundColor","_hexToRgb","_hexToRgb2","_slicedToArray","red","green","blue"],"sources":["/app/WcaOnRails/app/webpacker/lib/utils/calendar.js"],"sourcesContent":["const HEX_BASE = 16;\nconst HEX_CHANNEL_REGEX = /^#(?<r>[0-9A-Fa-f]{2})(?<g>[0-9A-Fa-f]{2})(?<b>[0-9A-Fa-f]{2})$/;\n\n/**\n * Convert a HEX color code to RGB values.\n *\n * @example\n * // returns [255, 255, 255]\n * getTextColor('#ffffff');\n *\n * @param {string} hexColor HEX color code to convert to RGB\n *\n * @returns {Array<number>} RBG values, defaults to `[0, 0, 0]` if `hexColor` cannot be parsed\n */\nexport const hexToRgb = (hexColor) => {\n  const match = hexColor.match(HEX_CHANNEL_REGEX);\n\n  if (match !== null) {\n    return [\n      parseInt(match.groups.r, HEX_BASE),\n      parseInt(match.groups.g, HEX_BASE),\n      parseInt(match.groups.b, HEX_BASE),\n    ];\n  }\n\n  return [0, 0, 0];\n};\n\nconst WHITE = '#ffffff';\nconst BLACK = '#000000';\n\n/**\n * Compute appropriate text color (black or white) based on how \"light\" or \"dark\"\n * the background color of a calendar item is.\n *\n * @example\n * // returns #000000 (black given white background color)\n * getTextColor('#ffffff');\n *\n * @param {string} backgroundColor Calendar item's background color (in HEX)\n *\n * @returns {string} white for \"dark\" backgrounds, black for \"light\" backgrounds\n */\nexport const getTextColor = (backgroundColor) => {\n  const [red, green, blue] = hexToRgb(backgroundColor);\n  // formula from https://stackoverflow.com/a/3943023\n  return (red * 0.299 + green * 0.587 + blue * 0.114) > 186 ? BLACK : WHITE;\n};\n"],"mappings":";;;;;;;;;AAAA,IAAMA,QAAQ,GAAG,EAAE;AACnB,IAAMC,iBAAiB,gBAAAC,WAAA,CAAG,qDAAiE;EAAAC,CAAA;EAAAC,CAAA;EAAAC,CAAA;AAAA;;AAE3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAQA,CAAIC,QAAQ,EAAK;EACpC,IAAMC,KAAK,GAAGD,QAAQ,CAACC,KAAK,CAACP,iBAAiB,CAAC;EAE/C,IAAIO,KAAK,KAAK,IAAI,EAAE;IAClB,OAAO,CACLC,QAAQ,CAACD,KAAK,CAACE,MAAM,CAACP,CAAC,EAAEH,QAAQ,CAAC,EAClCS,QAAQ,CAACD,KAAK,CAACE,MAAM,CAACN,CAAC,EAAEJ,QAAQ,CAAC,EAClCS,QAAQ,CAACD,KAAK,CAACE,MAAM,CAACL,CAAC,EAAEL,QAAQ,CAAC,CACnC;EACH;EAEA,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAClB,CAAC;AAED,IAAMW,KAAK,GAAG,SAAS;AACvB,IAAMC,KAAK,GAAG,SAAS;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMC,YAAY,GAAG,SAAfA,YAAYA,CAAIC,eAAe,EAAK;EAC/C,IAAAC,SAAA,GAA2BT,QAAQ,CAACQ,eAAe,CAAC;IAAAE,UAAA,GAAAC,cAAA,CAAAF,SAAA;IAA7CG,GAAG,GAAAF,UAAA;IAAEG,KAAK,GAAAH,UAAA;IAAEI,IAAI,GAAAJ,UAAA;EACvB;EACA,OAAQE,GAAG,GAAG,KAAK,GAAGC,KAAK,GAAG,KAAK,GAAGC,IAAI,GAAG,KAAK,GAAI,GAAG,GAAGR,KAAK,GAAGD,KAAK;AAC3E,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}