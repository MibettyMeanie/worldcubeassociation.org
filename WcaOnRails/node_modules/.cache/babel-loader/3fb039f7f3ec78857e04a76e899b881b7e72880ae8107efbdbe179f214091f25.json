{"ast":null,"code":"function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { changeTimezoneKeepingLocalTime, moveByIsoDuration, rescaleDuration } from \"../../lib/utils/edit-schedule\";\nexport var moveActivityByDuration = function moveActivityByDuration(activity, isoDuration) {\n  return _objectSpread(_objectSpread({}, activity), {}, {\n    startTime: moveByIsoDuration(activity.startTime, isoDuration),\n    endTime: moveByIsoDuration(activity.endTime, isoDuration),\n    childActivities: activity.childActivities.map(function (childActivity) {\n      return moveActivityByDuration(childActivity, isoDuration);\n    })\n  });\n};\nexport var scaleActivitiesByDuration = function scaleActivitiesByDuration(activity, isoDeltaStart, isoDeltaEnd) {\n  return _objectSpread(_objectSpread({}, activity), {}, {\n    startTime: moveByIsoDuration(activity.startTime, isoDeltaStart),\n    endTime: moveByIsoDuration(activity.endTime, isoDeltaEnd),\n    childActivities: activity.childActivities.map(function (childActivity, childIdx) {\n      // Unfortunately, scaling child activities (properly) is rocket science.\n      var nChildren = activity.childActivities.length;\n\n      // Say you have a parent activity with n=3 children,\n      // and you scale the start by -1 hour (i.e. 1 hour earlier).\n      //   In that case, the first child activity's start also has to be scaled by 1 hour.\n      // However, the second child activity's start only has to be scaled by 2/3 of 1 hour,\n      //   and the last has to be scaled by only 1/3 of 1 hour.\n      // In general, the i-th child of n children scales by (n-i)/n for the start of the activity.\n      var startScaleUp = (nChildren - childIdx) / nChildren;\n\n      // However, it doesn't end there. When a parent activity's _start_ scales,\n      //   only the startTime has to be manipulated.\n      // But for the children, the _endTime_ ALSO has to be manipulated\n      //   because even though only the start of the parent changes,\n      //   the children _move_ within that scaled parent as a whole.\n      // The scaling factor for the end of a child is the same as the scaling factor\n      //   for the start of the _next_ child.\n      var endScaleUp = (nChildren - (childIdx + 1)) / nChildren;\n      var childDeltaStartUp = rescaleDuration(isoDeltaStart, startScaleUp);\n      var childDeltaEndUp = rescaleDuration(isoDeltaStart, endScaleUp);\n\n      // Of course, this all has to happen recursively because children can have children!\n      var startScaledChild = scaleActivitiesByDuration(childActivity, childDeltaStartUp, childDeltaEndUp);\n\n      // And it gets even more crazy:\n      //   The same (n-i)/n logic from above has to be applied to the endDate as well,\n      //   but of course IN REVERSE! So the _last_ child moves the full amount,\n      //   the second-to-last child moves a little less, and the first child only moves a tiny bit.\n      var startScaleDown = childIdx / nChildren;\n      var endScaleDown = (childIdx + 1) / nChildren;\n      var childDeltaStartDown = rescaleDuration(isoDeltaEnd, startScaleDown);\n      var childDeltaEndDown = rescaleDuration(isoDeltaEnd, endScaleDown);\n\n      // Phew, we're done.\n      return scaleActivitiesByDuration(startScaledChild, childDeltaStartDown, childDeltaEndDown);\n    })\n  });\n};\nexport var changeActivityTimezone = function changeActivityTimezone(activity, oldTimezone, newTimezone) {\n  return _objectSpread(_objectSpread({}, activity), {}, {\n    startTime: changeTimezoneKeepingLocalTime(activity.startTime, oldTimezone, newTimezone),\n    endTime: changeTimezoneKeepingLocalTime(activity.endTime, oldTimezone, newTimezone),\n    childActivities: activity.childActivities.map(function (childActivity) {\n      return changeActivityTimezone(childActivity, oldTimezone, newTimezone);\n    })\n  });\n};","map":{"version":3,"names":["changeTimezoneKeepingLocalTime","moveByIsoDuration","rescaleDuration","moveActivityByDuration","activity","isoDuration","_objectSpread","startTime","endTime","childActivities","map","childActivity","scaleActivitiesByDuration","isoDeltaStart","isoDeltaEnd","childIdx","nChildren","length","startScaleUp","endScaleUp","childDeltaStartUp","childDeltaEndUp","startScaledChild","startScaleDown","endScaleDown","childDeltaStartDown","childDeltaEndDown","changeActivityTimezone","oldTimezone","newTimezone"],"sources":["/app/WcaOnRails/app/webpacker/components/EditSchedule/utils.js"],"sourcesContent":["import {\n  changeTimezoneKeepingLocalTime,\n  moveByIsoDuration,\n  rescaleDuration,\n} from '../../lib/utils/edit-schedule';\n\nexport const moveActivityByDuration = (activity, isoDuration) => ({\n  ...activity,\n  startTime: moveByIsoDuration(activity.startTime, isoDuration),\n  endTime: moveByIsoDuration(activity.endTime, isoDuration),\n  childActivities: activity.childActivities.map((childActivity) => (\n    moveActivityByDuration(childActivity, isoDuration)\n  )),\n});\n\nexport const scaleActivitiesByDuration = (activity, isoDeltaStart, isoDeltaEnd) => ({\n  ...activity,\n  startTime: moveByIsoDuration(activity.startTime, isoDeltaStart),\n  endTime: moveByIsoDuration(activity.endTime, isoDeltaEnd),\n  childActivities: activity.childActivities.map((childActivity, childIdx) => {\n    // Unfortunately, scaling child activities (properly) is rocket science.\n    const nChildren = activity.childActivities.length;\n\n    // Say you have a parent activity with n=3 children,\n    // and you scale the start by -1 hour (i.e. 1 hour earlier).\n    //   In that case, the first child activity's start also has to be scaled by 1 hour.\n    // However, the second child activity's start only has to be scaled by 2/3 of 1 hour,\n    //   and the last has to be scaled by only 1/3 of 1 hour.\n    // In general, the i-th child of n children scales by (n-i)/n for the start of the activity.\n    const startScaleUp = (nChildren - childIdx) / nChildren;\n\n    // However, it doesn't end there. When a parent activity's _start_ scales,\n    //   only the startTime has to be manipulated.\n    // But for the children, the _endTime_ ALSO has to be manipulated\n    //   because even though only the start of the parent changes,\n    //   the children _move_ within that scaled parent as a whole.\n    // The scaling factor for the end of a child is the same as the scaling factor\n    //   for the start of the _next_ child.\n    const endScaleUp = (nChildren - (childIdx + 1)) / nChildren;\n\n    const childDeltaStartUp = rescaleDuration(isoDeltaStart, startScaleUp);\n    const childDeltaEndUp = rescaleDuration(isoDeltaStart, endScaleUp);\n\n    // Of course, this all has to happen recursively because children can have children!\n    const startScaledChild = scaleActivitiesByDuration(\n      childActivity,\n      childDeltaStartUp,\n      childDeltaEndUp,\n    );\n\n    // And it gets even more crazy:\n    //   The same (n-i)/n logic from above has to be applied to the endDate as well,\n    //   but of course IN REVERSE! So the _last_ child moves the full amount,\n    //   the second-to-last child moves a little less, and the first child only moves a tiny bit.\n    const startScaleDown = childIdx / nChildren;\n    const endScaleDown = (childIdx + 1) / nChildren;\n\n    const childDeltaStartDown = rescaleDuration(isoDeltaEnd, startScaleDown);\n    const childDeltaEndDown = rescaleDuration(isoDeltaEnd, endScaleDown);\n\n    // Phew, we're done.\n    return scaleActivitiesByDuration(startScaledChild, childDeltaStartDown, childDeltaEndDown);\n  }),\n});\n\nexport const changeActivityTimezone = (activity, oldTimezone, newTimezone) => ({\n  ...activity,\n  startTime: changeTimezoneKeepingLocalTime(activity.startTime, oldTimezone, newTimezone),\n  endTime: changeTimezoneKeepingLocalTime(activity.endTime, oldTimezone, newTimezone),\n  childActivities: activity.childActivities.map((childActivity) => (\n    changeActivityTimezone(\n      childActivity,\n      oldTimezone,\n      newTimezone,\n    )\n  )),\n});\n"],"mappings":";;;;;AAAA,SACEA,8BAA8B,EAC9BC,iBAAiB,EACjBC,eAAe;AAGjB,OAAO,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAsBA,CAAIC,QAAQ,EAAEC,WAAW;EAAA,OAAAC,aAAA,CAAAA,aAAA,KACvDF,QAAQ;IACXG,SAAS,EAAEN,iBAAiB,CAACG,QAAQ,CAACG,SAAS,EAAEF,WAAW,CAAC;IAC7DG,OAAO,EAAEP,iBAAiB,CAACG,QAAQ,CAACI,OAAO,EAAEH,WAAW,CAAC;IACzDI,eAAe,EAAEL,QAAQ,CAACK,eAAe,CAACC,GAAG,CAAC,UAACC,aAAa;MAAA,OAC1DR,sBAAsB,CAACQ,aAAa,EAAEN,WAAW,CAAC;IAAA,CACnD;EAAC;AAAA,CACF;AAEF,OAAO,IAAMO,yBAAyB,GAAG,SAA5BA,yBAAyBA,CAAIR,QAAQ,EAAES,aAAa,EAAEC,WAAW;EAAA,OAAAR,aAAA,CAAAA,aAAA,KACzEF,QAAQ;IACXG,SAAS,EAAEN,iBAAiB,CAACG,QAAQ,CAACG,SAAS,EAAEM,aAAa,CAAC;IAC/DL,OAAO,EAAEP,iBAAiB,CAACG,QAAQ,CAACI,OAAO,EAAEM,WAAW,CAAC;IACzDL,eAAe,EAAEL,QAAQ,CAACK,eAAe,CAACC,GAAG,CAAC,UAACC,aAAa,EAAEI,QAAQ,EAAK;MACzE;MACA,IAAMC,SAAS,GAAGZ,QAAQ,CAACK,eAAe,CAACQ,MAAM;;MAEjD;MACA;MACA;MACA;MACA;MACA;MACA,IAAMC,YAAY,GAAG,CAACF,SAAS,GAAGD,QAAQ,IAAIC,SAAS;;MAEvD;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAMG,UAAU,GAAG,CAACH,SAAS,IAAID,QAAQ,GAAG,CAAC,CAAC,IAAIC,SAAS;MAE3D,IAAMI,iBAAiB,GAAGlB,eAAe,CAACW,aAAa,EAAEK,YAAY,CAAC;MACtE,IAAMG,eAAe,GAAGnB,eAAe,CAACW,aAAa,EAAEM,UAAU,CAAC;;MAElE;MACA,IAAMG,gBAAgB,GAAGV,yBAAyB,CAChDD,aAAa,EACbS,iBAAiB,EACjBC,eACF,CAAC;;MAED;MACA;MACA;MACA;MACA,IAAME,cAAc,GAAGR,QAAQ,GAAGC,SAAS;MAC3C,IAAMQ,YAAY,GAAG,CAACT,QAAQ,GAAG,CAAC,IAAIC,SAAS;MAE/C,IAAMS,mBAAmB,GAAGvB,eAAe,CAACY,WAAW,EAAES,cAAc,CAAC;MACxE,IAAMG,iBAAiB,GAAGxB,eAAe,CAACY,WAAW,EAAEU,YAAY,CAAC;;MAEpE;MACA,OAAOZ,yBAAyB,CAACU,gBAAgB,EAAEG,mBAAmB,EAAEC,iBAAiB,CAAC;IAC5F,CAAC;EAAC;AAAA,CACF;AAEF,OAAO,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAsBA,CAAIvB,QAAQ,EAAEwB,WAAW,EAAEC,WAAW;EAAA,OAAAvB,aAAA,CAAAA,aAAA,KACpEF,QAAQ;IACXG,SAAS,EAAEP,8BAA8B,CAACI,QAAQ,CAACG,SAAS,EAAEqB,WAAW,EAAEC,WAAW,CAAC;IACvFrB,OAAO,EAAER,8BAA8B,CAACI,QAAQ,CAACI,OAAO,EAAEoB,WAAW,EAAEC,WAAW,CAAC;IACnFpB,eAAe,EAAEL,QAAQ,CAACK,eAAe,CAACC,GAAG,CAAC,UAACC,aAAa;MAAA,OAC1DgB,sBAAsB,CACpBhB,aAAa,EACbiB,WAAW,EACXC,WACF,CAAC;IAAA,CACF;EAAC;AAAA,CACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}