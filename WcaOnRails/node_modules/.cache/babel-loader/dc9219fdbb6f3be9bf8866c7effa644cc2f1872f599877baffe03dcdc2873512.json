{"ast":null,"code":"import _last from \"lodash/last\";\nimport _pick from \"lodash/pick\";\nimport { roomWcifFromId, venueWcifFromRoomId } from \"./wcif\";\nimport { newActivityId } from \"./edit-schedule\";\nimport { scheduleElementSelector } from \"../helpers/edit-schedule\";\nvar tzConverterHandlers = {};\nexport var calendarHandlers = {};\nexport function isoToMoment(iso) {\n  return tzConverterHandlers.isoStringToAmbiguousMoment(iso);\n}\nexport function momentToIso(moment) {\n  return tzConverterHandlers.ambiguousMomentToIsoString(moment);\n}\nexport function selectedEventInCalendar() {\n  var matching = $(scheduleElementSelector).fullCalendar('clientEvents', function (event) {\n    return event.selected;\n  });\n  return matching.length > 0 ? matching[0] : null;\n}\n\n// dataToFcEvent is called in two contexts:\n//   - as a eventDataTransform callback by fullcalendar\n//   - as a way to create an event object from activity data\n// In the first case it may contain attributes that are already defined/changed\n// during the event life in FC, and that we must preserve:\n//   - start, end, selected, title\n// In any case, the data passed will contain activityCode and childActivities,\n// as we propagate them all the time.\n// We must make sure the returned object contains at least:\n//   - id, title, start, end, activityCode, childActivities\nexport function dataToFcEvent(data) {\n  // Create a FullCalendar event from an activity\n  // This copy only defined properties\n  var eventData = _pick(data, ['id', 'title', 'activityCode', 'childActivities', 'start', 'end', 'selected']);\n\n  // Get missing attributes from the activity data\n\n  // Generate a new activity id if needed\n  if (!Object.prototype.hasOwnProperty.call(eventData, 'id')) {\n    eventData.id = newActivityId();\n  }\n  if (!Object.prototype.hasOwnProperty.call(eventData, 'title')) {\n    eventData.title = data.name;\n  }\n\n  // While in FC, any time is ambiguously-zoned\n  // We'll add back the room's venue's timezone when exporting the WCIF\n  if (!Object.prototype.hasOwnProperty.call(eventData, 'start')) {\n    eventData.start = isoToMoment(data.startTime);\n  }\n  if (!Object.prototype.hasOwnProperty.call(eventData, 'end')) {\n    eventData.end = isoToMoment(data.endTime);\n  }\n  return eventData;\n}\n\n// DO NOT call this when resizing/dragging!!!\n// When resizing/dragging, FC add the event to a 'fc-helper-container', which\n// has the css to be displayed as the selected event.\n// Instead you'd rather want to:\n//   - visually remove any selected event when resizing/dragging starts\n//   (see onDragStart@fullcalendar.js)\n//   - actually update FC's internal states when resizing/dragging is over, as\n//   it is safe to call this function then.\nexport function singleSelectEvent(ev) {\n  var event = ev;\n  // return if the event has been already selected\n  if (event.selected) {\n    return;\n  }\n  var events = $(scheduleElementSelector).fullCalendar('clientEvents');\n  events.forEach(function (el) {\n    var elem = el;\n    if (elem.selected && event.id !== elem.id) {\n      elem.selected = false;\n      $(scheduleElementSelector).fullCalendar('updateEvent', elem);\n    }\n  });\n  event.selected = true;\n  $(scheduleElementSelector).fullCalendar('updateEvent', event);\n}\nexport function singleSelectLastEvent(scheduleWcif, selectedRoom) {\n  var room = roomWcifFromId(scheduleWcif, selectedRoom);\n  if (room) {\n    if (room.activities.length > 0) {\n      var lastActivity = _last(room.activities);\n      var fcEvent = $(scheduleElementSelector).fullCalendar('clientEvents', lastActivity.id)[0];\n      singleSelectEvent(fcEvent);\n    }\n  }\n}\nexport function fcEventToActivity(event) {\n  // Build a cleaned up activity from a FullCalendar event\n  var activity = {\n    id: event.id,\n    name: event.title,\n    activityCode: event.activityCode\n  };\n  if (Object.prototype.hasOwnProperty.call(event, 'start')) {\n    activity.startTime = momentToIso(event.start);\n  }\n  if (Object.prototype.hasOwnProperty.call(event, 'end')) {\n    activity.endTime = momentToIso(event.end);\n  }\n  if (Object.prototype.hasOwnProperty.call(event, 'childActivities')) {\n    // Not modified by FC, put them back anyway\n    activity.childActivities = event.childActivities;\n  } else {\n    activity.childActivities = [];\n  }\n  return activity;\n}\nfunction isoStringToAmbiguousMoment(editor, isoString) {\n  var venue = venueWcifFromRoomId(editor.props.scheduleWcif, editor.state.selectedRoom);\n  var tz = venue.timezone;\n  // Using FC's moment because it has a custom \"stripZone\" feature\n  // The final FC display will be timezone-free, and the user expect a calendar\n  // in the venue's TZ.\n  // First convert the time received into the venue's timezone, then strip its value\n  return $.fullCalendar.moment(isoString).tz(tz).stripZone();\n}\nfunction ambiguousMomentToIsoString(editor, momentObject) {\n  var venue = venueWcifFromRoomId(editor.props.scheduleWcif, editor.state.selectedRoom);\n  var tz = venue.timezone;\n  // Take the moment and \"concatenate\" the UTC offset of the timezone at that time\n  // momentObject is a FC (ambiguously zoned) moment, therefore format() returns a zone free string\n  return window.moment.tz(momentObject.format(), tz).utc().format();\n}\nexport function setupConvertHandlers(editor) {\n  tzConverterHandlers.isoStringToAmbiguousMoment = function (s) {\n    return isoStringToAmbiguousMoment(editor, s);\n  };\n  tzConverterHandlers.ambiguousMomentToIsoString = function (m) {\n    return ambiguousMomentToIsoString(editor, m);\n  };\n}\nexport function addActivityToCalendar(data) {\n  var renderItOnCalendar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return calendarHandlers.addActivityToCalendar(data, renderItOnCalendar);\n}\nexport function eventModifiedInCalendar(event) {\n  return calendarHandlers.eventModifiedInCalendar(event);\n}\nexport function removeEventFromCalendar(event) {\n  return calendarHandlers.removeEventFromCalendar(event);\n}","map":{"version":3,"names":["roomWcifFromId","venueWcifFromRoomId","newActivityId","scheduleElementSelector","tzConverterHandlers","calendarHandlers","isoToMoment","iso","isoStringToAmbiguousMoment","momentToIso","moment","ambiguousMomentToIsoString","selectedEventInCalendar","matching","$","fullCalendar","event","selected","length","dataToFcEvent","data","eventData","_pick","Object","prototype","hasOwnProperty","call","id","title","name","start","startTime","end","endTime","singleSelectEvent","ev","events","forEach","el","elem","singleSelectLastEvent","scheduleWcif","selectedRoom","room","activities","lastActivity","_last","fcEvent","fcEventToActivity","activity","activityCode","childActivities","editor","isoString","venue","props","state","tz","timezone","stripZone","momentObject","window","format","utc","setupConvertHandlers","s","m","addActivityToCalendar","renderItOnCalendar","arguments","undefined","eventModifiedInCalendar","removeEventFromCalendar"],"sources":["/app/WcaOnRails/app/webpacker/lib/utils/calendar.js"],"sourcesContent":["import _ from 'lodash';\nimport {\n  roomWcifFromId,\n  venueWcifFromRoomId,\n} from './wcif';\nimport { newActivityId } from './edit-schedule';\nimport { scheduleElementSelector } from '../helpers/edit-schedule';\n\nconst tzConverterHandlers = {\n};\n\nexport const calendarHandlers = {\n};\n\nexport function isoToMoment(iso) {\n  return tzConverterHandlers.isoStringToAmbiguousMoment(iso);\n}\n\nexport function momentToIso(moment) {\n  return tzConverterHandlers.ambiguousMomentToIsoString(moment);\n}\n\nexport function selectedEventInCalendar() {\n  const matching = $(scheduleElementSelector).fullCalendar('clientEvents', (event) => event.selected);\n  return matching.length > 0 ? matching[0] : null;\n}\n\n// dataToFcEvent is called in two contexts:\n//   - as a eventDataTransform callback by fullcalendar\n//   - as a way to create an event object from activity data\n// In the first case it may contain attributes that are already defined/changed\n// during the event life in FC, and that we must preserve:\n//   - start, end, selected, title\n// In any case, the data passed will contain activityCode and childActivities,\n// as we propagate them all the time.\n// We must make sure the returned object contains at least:\n//   - id, title, start, end, activityCode, childActivities\nexport function dataToFcEvent(data) {\n  // Create a FullCalendar event from an activity\n  // This copy only defined properties\n  const eventData = _.pick(data, ['id', 'title', 'activityCode', 'childActivities', 'start', 'end', 'selected']);\n\n  // Get missing attributes from the activity data\n\n  // Generate a new activity id if needed\n  if (!Object.prototype.hasOwnProperty.call(eventData, 'id')) {\n    eventData.id = newActivityId();\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(eventData, 'title')) {\n    eventData.title = data.name;\n  }\n\n  // While in FC, any time is ambiguously-zoned\n  // We'll add back the room's venue's timezone when exporting the WCIF\n  if (!Object.prototype.hasOwnProperty.call(eventData, 'start')) {\n    eventData.start = isoToMoment(data.startTime);\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(eventData, 'end')) {\n    eventData.end = isoToMoment(data.endTime);\n  }\n\n  return eventData;\n}\n\n// DO NOT call this when resizing/dragging!!!\n// When resizing/dragging, FC add the event to a 'fc-helper-container', which\n// has the css to be displayed as the selected event.\n// Instead you'd rather want to:\n//   - visually remove any selected event when resizing/dragging starts\n//   (see onDragStart@fullcalendar.js)\n//   - actually update FC's internal states when resizing/dragging is over, as\n//   it is safe to call this function then.\nexport function singleSelectEvent(ev) {\n  const event = ev;\n  // return if the event has been already selected\n  if (event.selected) {\n    return;\n  }\n  const events = $(scheduleElementSelector).fullCalendar('clientEvents');\n  events.forEach((el) => {\n    const elem = el;\n    if (elem.selected && (event.id !== elem.id)) {\n      elem.selected = false;\n      $(scheduleElementSelector).fullCalendar('updateEvent', elem);\n    }\n  });\n  event.selected = true;\n  $(scheduleElementSelector).fullCalendar('updateEvent', event);\n}\n\nexport function singleSelectLastEvent(scheduleWcif, selectedRoom) {\n  const room = roomWcifFromId(scheduleWcif, selectedRoom);\n  if (room) {\n    if (room.activities.length > 0) {\n      const lastActivity = _.last(room.activities);\n      const fcEvent = $(scheduleElementSelector).fullCalendar('clientEvents', lastActivity.id)[0];\n      singleSelectEvent(fcEvent);\n    }\n  }\n}\n\nexport function fcEventToActivity(event) {\n  // Build a cleaned up activity from a FullCalendar event\n  const activity = {\n    id: event.id,\n    name: event.title,\n    activityCode: event.activityCode,\n  };\n  if (Object.prototype.hasOwnProperty.call(event, 'start')) {\n    activity.startTime = momentToIso(event.start);\n  }\n  if (Object.prototype.hasOwnProperty.call(event, 'end')) {\n    activity.endTime = momentToIso(event.end);\n  }\n  if (Object.prototype.hasOwnProperty.call(event, 'childActivities')) {\n    // Not modified by FC, put them back anyway\n    activity.childActivities = event.childActivities;\n  } else {\n    activity.childActivities = [];\n  }\n  return activity;\n}\nfunction isoStringToAmbiguousMoment(editor, isoString) {\n  const venue = venueWcifFromRoomId(editor.props.scheduleWcif, editor.state.selectedRoom);\n  const tz = venue.timezone;\n  // Using FC's moment because it has a custom \"stripZone\" feature\n  // The final FC display will be timezone-free, and the user expect a calendar\n  // in the venue's TZ.\n  // First convert the time received into the venue's timezone, then strip its value\n  return $.fullCalendar.moment(isoString).tz(tz).stripZone();\n}\n\nfunction ambiguousMomentToIsoString(editor, momentObject) {\n  const venue = venueWcifFromRoomId(editor.props.scheduleWcif, editor.state.selectedRoom);\n  const tz = venue.timezone;\n  // Take the moment and \"concatenate\" the UTC offset of the timezone at that time\n  // momentObject is a FC (ambiguously zoned) moment, therefore format() returns a zone free string\n  return window.moment.tz(momentObject.format(), tz).utc().format();\n}\n\nexport function setupConvertHandlers(editor) {\n  tzConverterHandlers.isoStringToAmbiguousMoment = (s) => isoStringToAmbiguousMoment(editor, s);\n  tzConverterHandlers.ambiguousMomentToIsoString = (m) => ambiguousMomentToIsoString(editor, m);\n}\n\nexport function addActivityToCalendar(data, renderItOnCalendar = true) {\n  return calendarHandlers.addActivityToCalendar(data, renderItOnCalendar);\n}\n\nexport function eventModifiedInCalendar(event) {\n  return calendarHandlers.eventModifiedInCalendar(event);\n}\n\nexport function removeEventFromCalendar(event) {\n  return calendarHandlers.removeEventFromCalendar(event);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}